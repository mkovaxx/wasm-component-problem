// Generated by `wit-bindgen` 0.20.0. DO NOT EDIT!
// Options used:
pub mod example {
    pub mod parser {

        #[allow(clippy::all)]
        pub mod example_parser_parsing {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            pub type Ast = super::super::super::example::types::types::Ast;
            #[allow(unused_unsafe, clippy::all)]
            /// Parse the source of a module into an AST
            pub fn parse(source: &str) -> Ast {
                unsafe {
                    let vec0 = source;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "example:parser/example-parser-parsing")]
                    extern "C" {
                        #[link_name = "parse"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    use super::super::super::example::types::types::Ast as V1;
                    let v1 = match ret {
                        n => {
                            debug_assert_eq!(n, 0, "invalid enum discriminant");
                            V1::Empty
                        }
                    };
                    v1
                }
            }
        }
    }
    pub mod parser0_1_0 {

        #[allow(clippy::all)]
        pub mod parsing {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            pub type Ast = super::super::super::example::types::types::Ast;
            #[allow(unused_unsafe, clippy::all)]
            /// Parse the source of a module into an AST
            pub fn parse(source: &str) -> Ast {
                unsafe {
                    let vec0 = source;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "example:parser/parsing@0.1.0")]
                    extern "C" {
                        #[link_name = "parse"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    use super::super::super::example::types::types::Ast as V1;
                    let v1 = match ret {
                        n => {
                            debug_assert_eq!(n, 0, "invalid enum discriminant");
                            V1::Empty
                        }
                    };
                    v1
                }
            }
        }
    }
    pub mod types {

        #[allow(clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            #[derive(Clone, Copy)]
            pub enum Ast {
                Empty,
            }
            impl ::core::fmt::Debug for Ast {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Ast::Empty => f.debug_tuple("Ast::Empty").finish(),
                    }
                }
            }
        }
    }
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.20.0:cli:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 393] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x8f\x02\x01A\x02\x01\
A\x07\x01B\x04\x01q\x01\x05empty\0\0\x04\0\x03ast\x03\0\0\x01q\x01\x05empty\0\0\x04\
\0\x06module\x03\0\x02\x03\x01\x19example:types/types@0.1.0\x05\0\x02\x03\0\0\x03\
ast\x01B\x04\x02\x03\x02\x01\x01\x04\0\x03ast\x03\0\0\x01@\x01\x06sources\0\x01\x04\
\0\x05parse\x01\x02\x03\x01\x1cexample:parser/parsing@0.1.0\x05\x02\x01B\x04\x02\
\x03\x02\x01\x01\x04\0\x03ast\x03\0\0\x01@\x01\x06sources\0\x01\x04\0\x05parse\x01\
\x02\x03\x01%example:parser/example-parser-parsing\x05\x03\x04\x01\x15example:cl\
i/cli@0.1.0\x04\0\x0b\x09\x01\0\x03cli\x03\0\0\0G\x09producers\x01\x0cprocessed-\
by\x02\x0dwit-component\x070.201.0\x10wit-bindgen-rust\x060.20.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
